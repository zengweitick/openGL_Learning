# 深度测试

- 前言

  在[坐标系统](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\笔记\6. 坐标系统.md)章节，我们在设计多彩箱子的 时候使用过的Z缓冲机制实现**深度缓冲**(Depth Buffer)来防止被阻挡的面渲染到其它面的前面。这节我们将会更加深入地讨论这些储存在深度缓冲（或z缓冲(z-buffer)）中的深度值(Depth Value)，以及它们是如何确定一个片段是处于其它片段后方的。

  ```c++
  glEnable(GL_DEPTH_TEST);//启用深度测试
  ```

- 理论知识

  **深度缓冲**

  深度缓冲区与帧缓冲区相对应，用于记录上面每个像素的深度值(在3D坐标当中距离摄像机的距离即Z值)，通过深度缓冲区，我们可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。

  深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

  **深度缓冲运行原理**

  OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值（存储Z值）。如果深度测试失败了，片段将会被丢弃。

  深度缓冲的运行是在片段着色器运行之后在==屏幕空间==中运行的（扩展阅读：[提前深度测试](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/)）；屏幕空间坐标与通过OpenGL的==glViewport==所定义的视口密切相关，并且可以直接使用GLSL内建变量==gl_FragCoord==从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。

   

- 使用

  1. 启动深度缓冲机制

     ```c++
     glEnable(GL_DEPTH_TEST);
     ```

  2. 果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值

     ```c++
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     ```

  3. 如果仅限于检测深度值然后丢弃相应的片段但不更新深度缓冲，基本上来说，你在使用一个只读的(Read-only)深度缓冲。OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为`GL_FALSE`就可以了：

     ```c++
     glDepthMask(GL_FALSE);//只有在启动深度测试时才有效
     ```

  至此基本设置已经完成。以下是针对深度缓冲的操作。

  - 深度测试函数

    - 作用：用来操控什么时候该通过或丢弃一个片段以及什么时候去更新深度缓冲。

    - 操作函数

      ```c++
      glDepthFunc(OPTION);
      ```

      OPTION取值表

      |     参数      |                     描述                     |
      | :-----------: | :------------------------------------------: |
      |   GL_ALWAYS   |               永远通过深度测试               |
      |   GL_NEVER    |              永远不通过深度测试              |
      | GL_LESS(默认) |    在片段深度值小于缓冲的深度值时通过测试    |
      |   GL_EQUAL    |   在片段深度值等于缓冲区的深度值时通过测试   |
      |   GL_LEQUAL   | 在片段深度值小于等于缓冲区的深度值时通过测试 |
      |  GL_GREATER   |   在片段深度值大于缓冲区的深度值时通过测试   |
      |  GL_NOTEQUAL  |  在片段深度值不等于缓冲区的深度值时通过测试  |
      |   GL_GEQUAL   | 在片段深度值大于等于缓冲区的深度值时通过测试 |

  - 深度值精度

    由于深度值Z值是0.0-1.0之间的数值，而深度值是在观察空间（NEAR-FAR）进行设置的,NEAR与FAR值比较大；如何进行转化？

    ```
    NEAR为观察者空间的近平面，FAR为观察者空间的远平面
    ```

    1. 线性转化
       $$
       \begin{equation} F_{depth} = \frac{z - near}{far - near} \end{equation}
       $$
       
       ```
       这里的near和far值是我们之前提供给投影矩阵设置可视平截头体的（见坐标系统）那个 near 和 far 值。这个方程需要平截头体中的一个z值，并将它变换到了[0, 1]的范围中。
       ```
       
       优点：
       
       转换规则简单，计算简单易懂。
       
       缺点：
       
       资源浪费严重，对于远近深度值没有很好处理。我们不需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度但线性方程并不会考虑这一点。因此实践当中并不会采用这种方案。
       
    2. 非线性转化
       $$
       \begin{equation} F_{depth} = \frac{1/z - 1/near}{1/far - 1/near} \end{equation}
       $$
    
       ```
       方程与1/z成正比同时也兼顾线性转化的优点不存在线性优化的缺点。
       ```
    
       ![](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\笔记\assets\深度测试.png)
    
       ```
       Z值与深度值之间的关系图
       ```
    
  - 深度缓冲的可视化

    我们知道片段着色器中，内建gl_FragCoord向量的z值包含了那个特定片段的深度值。如果我们将这个深度值输出为颜色，我们可以显示场景中所有片段的深度值。我们可以根据片段的深度值返回一个颜色向量来完成这一工作：

    ```c++
    void main()
    {
        FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
    }
    ```

    [见官网](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/)

  - 深度冲突

    [见官网](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/)

    

  

  
