# 摄像机

![](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\图片\camera_first.png)

- 是什么是摄像机？

  摄像机的出现是在上一节当中将的观察者阶段的，观察者阶段我们的视角即为摄像机的视角

- 摄像机以及观察空间

  当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。如上图所示 。即以摄像机为原点创建一个三维坐标系。

- 如何设置摄像机？

  1. 设置摄像机的位置（此位置是相对于世界坐标而言的，因此需要一个向量直接指明）

     ```c++
     glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
     //注意 该向量只是指明摄像机的位置，并没有指明摄像机对准的位置，同时需要注意的是在世界坐标系当中Z轴正方向是指向我们的。理解这一点才能理解第二步
     ```

  2.  设置摄像机对准的位置 

     在向量运算当中，两向量相减，结果指向被减向量；在第一步当中我们定义了一个摄像机位置向量，还有一个隐藏的向量即原点向量cameraTarget （0，0，0），由于我们希望摄像机对准Z轴正方向，因此只需要：

     ```c++
     glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
     glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
     //得到的cameraDirection即为摄像机对准的方向。同时也是摄像机坐标系的Z轴，在下一节当中就会应用到
     ```

     

- 如何创建以摄像机为原点的坐标系？

  Z轴不需要我们创建了，cameraDirection即为Z轴正方向 

  1. 定义右轴（右向量），该轴表示摄像机坐标系的x轴 ，当然你可以直接定义，但是为了强调向量操作我们还是在定义右轴之前先定义上向量，然后利用==叉乘==得出右向量（x轴向量）

     ```c++
     glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
     glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));//标准化
     ```

  2. 定义上轴，现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把右向量和方向向量进行叉乘（注意叉乘顺序）： 

     ```c++
     glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
     ```

     

- LookAt

  1. LookAt出现的意义：

     由于我们在观察者空间希望以摄像机坐标系为参考点来观察物体，因此如何将世界空间的物体坐标转换成摄像机空间的坐标成为了LookAt矩阵存在的价值。使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间（即我们刚刚定义的摄像机坐标系），你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是**LookAt**矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了

     

  2. 如何定义LookAt矩阵

​     
$$
 LookAt=
 \left|
 	\begin{matrix}
 		R_{x} &R_{y} &R_{z} & 0\\
 		U_{x} &U_{y}&U_{z} &0\\
 		D_{x} & D_{y} &D_{z} &0 \\
 		0& 0 & 0 &1
 	\end{matrix}
 \right| *
 \left|
 	\begin{matrix}
 1& 0&0 &- P_{x}\\
 0& 1&0 &-P_{y}\\
 0&0&1&-P_{x}\\
 0&0&0&1
 \end{matrix}
 \right|
$$

 ```c++
 注：
 其中R是右向量，U是上向量，D是方向向量P是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向
 ```

  3. 如何使用LookAt:

      幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩 阵，我们可以把它当作我们的观察矩阵：

     ```c++
     glm::mat4 view;
     view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), //摄像机位置向量
                glm::vec3(0.0f, 0.0f, 0.0f),         //目标位置向量
                glm::vec3(0.0f, 1.0f, 0.0f));        //上向量
     ```
    
      它会创建一个和在上一节（坐标系统）使用的一样的观察矩阵。 
    4. 代码示例

```c++
//vertexSource.txt
#version 330 core
layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0 
layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1
out vec3 ourColor; // 向片段着色器输出一个颜色
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    gl_Position =projection * view * model * vec4(aPos, 1.0);  //顺序必须正确！
   
    ourColor = aColor;  
}
//fragmentSource.txt
#version 330 core
out vec4 FragColor;  
in vec3 ourColor;
void main()
{
   FragColor = vec4(ourColor, 1.0f);
}
//main.cpp
#define GLEW_STATIC
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include<MyInclude/shader_s.h>
#include<filesystem>
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
using namespace std;

float vertices[] = {
    // positions          // colors           // texture coords
    // 0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
    // 0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
    //-0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
    //-0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left 

   - 0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f,

    -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  0.0f, 0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 1.0f,

    -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,

     0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
     0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
     0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,

    -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
     0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 1.0f
};
glm::vec3 cubePositions[] = {
       glm::vec3(0.0f,  0.0f,  0.0f),
       glm::vec3(2.0f,  5.0f, -15.0f),
       glm::vec3(-1.5f, -2.2f, -2.5f),
       glm::vec3(-3.8f, -2.0f, -12.3f),
       glm::vec3(2.4f, -0.4f, -3.5f),
       glm::vec3(-1.7f,  3.0f, -7.5f),
       glm::vec3(1.3f, -2.0f, -2.5f),
       glm::vec3(1.5f,  2.0f, -2.5f),
       glm::vec3(1.5f,  0.2f, -1.5f),
       glm::vec3(-1.3f,  1.0f, -1.5f)
};
unsigned int indices[] = {
       0, 1, 3, // first triangle
       1, 2, 3  // second triangle
};

const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;
//初始化函数
void init();
void processInput(GLFWwindow* window);
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
int main()
{
    init();
    //创建窗口
    GLFWwindow* window = glfwCreateWindow(800, 600, "MutiColor_Triangle", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "failed to create window...." << std::endl;
        glfwTerminate();
        return -1;
    }
    //将窗口上下文设置为主线程的上下文
    glfwMakeContextCurrent(window);
    //注册回调函数
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    //初始化GLAD库，并加载所有openGL指针
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }
    glEnable(GL_DEPTH_TEST);

    //********************编写着色程序对象*****************************
    Shader myshader = Shader("vertexSource.txt", "fragmentSource.txt");

    unsigned int VBO, VAO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);
    //索引对象
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    //将数据存入VBO对象
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    //将索引数据存入EBO对象
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);



    //位置属性
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    // 颜色属性
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    //纹理属性
    
    myshader.use();
    while (!glfwWindowShouldClose(window))
    {
        processInput(window);
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        //glClear(GL_COLOR_BUFFER_BIT);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!
        //glm::mat4 transform = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
        //transform = glm::rotate(transform, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
        //transform = glm::translate(transform, glm::vec3(0.5f, -0.5f, 0.0f));
        myshader.use();
        // create transformations
        //glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
        float radius = 10.0f;
        float camX = sin(glfwGetTime()) * radius;
        float camZ = cos(glfwGetTime()) * radius;
        glm::mat4 view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0),glm::vec3(0.0, 1.0, 0.0));         
        glm::mat4 projection = glm::mat4(1.0f);
        /*model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));*/
       // model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));
        view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
        projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
        // retrieve the matrix uniform locations
        unsigned int modelLoc = glGetUniformLocation(myshader.ID, "model");
        unsigned int viewLoc = glGetUniformLocation(myshader.ID, "view");
        // pass them to the shaders (3 different ways)
       // glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &view[0][0]);
        // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it's often best practice to set it outside the main loop only once.
        myshader.setMat4("projection", projection);
        glBindVertexArray(VAO);
        //glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        for (int i = 0; i < 10; i++)
        {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, cubePositions[i]);
            float angle = 20.0f * i;
            model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
            myshader.setMat4("model", model);
            glDrawArrays(GL_TRIANGLES, 0, 36);
        }
       // glDrawArrays(GL_TRIANGLES, 0, 36);
        
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteBuffers(1, &EBO);
    glfwTerminate();
    return 0;
}
void init()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
}
void processInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}
```



- 自由移动（加入键盘操作）

  上述代码是我们设定好轨道让摄像机移动，现在实现键盘移动摄像机。我们需要==自由移动==来帮助我们实现这个功能。

  ```c++
  glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
  glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
  glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);
  ```

  LookAt函数系数

  ```c++
  view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
  //第二个参数值得分析，第二个参数设置的是摄像机注视的方向；之前我们让摄像机注视世界坐标的原点位置（0，0，0）；现在我们让摄像机注视（cameraPos+cameraFront位置，这样能保证无论我们怎么移动，摄像机都会注视着目标方向。cameraFront这个变量相当于是把你看的方向固定到平行于z轴，写成-1,而不是0，这样就算你左右移动了也还是固定是新的平行于z轴的方向。当然改成-2，或者更多也行
  ```

  加入键盘命令解释

  ```c++
  void processInput(GLFWwindow *window)
  {
      ...
      float cameraSpeed = 0.05f; // adjust accordingly
      if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
          cameraPos += cameraSpeed * cameraFront;
      if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
          cameraPos -= cameraSpeed * cameraFront;
      if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
          cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
      if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
          cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
  }
  //爆红的变量，需要定义成全局变量
  ```

- deltaTime 值(速度)

  - 简介

    ```c++
    在游戏与动画当中，为保持前后帧切换速度均衡，系统会计算帧切换前后的时间差(Deltatime)变量。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。而我们要做的就是计算deltaTime，系统会自动检查并做出调整，我们只需要进行加减乘除。
    ```

  - 使用

    ```c++
    float deltaTime = 0.0f; // 当前帧与上一帧的时间差
    float lastFrame = 0.0f; // 上一帧的时间
    
    float currentFrame = glfwGetTime();
    deltaTime = currentFrame - lastFrame;
    lastFrame = currentFrame;
    ```

    现在我们得到deltaTime变量值，我们把他加进去就OK

    ```c++
    void processInput(GLFWwindow *window)
    {
      float cameraSpeed = 2.5f * deltaTime;
      ...
    }
    ```

- 欧拉角（加入鼠标）

  - 简介

    欧拉角根据调整的方向不同分为三种：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll) 

    ![](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\图片\欧拉角.png)

    在摄像机坐标系当中我们很少用滚动角。

    1. 俯仰角

       ![](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\图片\俯仰角.png)

       ```c++
       //注意：
       1、 图中斜边为1
       2、 x/z表示摄像机移动方向平行于x或z轴（x轴与z轴在同一平面）
       ```

       从图中我们可以看到对于一个给定俯仰角的y值等于sin θ： 

       ```c++
       direction.y = sin(glm::radians(pitch)); // 注意我们先把角度转为弧度
       ```

       这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于： 

       ```c++
       direction.x = cos(glm::radians(pitch));
       direction.z = cos(glm::radians(pitch));
       //思考：为什么在x轴与z轴分量相同？
       //答：斜边（等于1）在x或z轴的投影是一样的
       ```
     ```
    
     
    
     ```
  2. 偏航角
    
     ![](C:\Users\曾伟\Desktop\typora笔记\计算机图形学笔记\图片\偏航角.png)
    
       ```c++
       //注意：
       此处我们应该有三维意识，在俯仰角当中斜边为1；而在偏航角当中，斜边不为1，而是cos (pitch)
       ```
    
     就像俯仰角的三角形一样，我们可以看到x分量取决于`cos(yaw)`的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量： 
    
       ```c++
       direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); 
       // 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的
       direction.y = sin(glm::radians(pitch));
     direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));
       ```
    ```
       
       至此，这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量了（计算方法） 。此时我们可以通过鼠标活动来获取角度。
    ```

- 鼠标移动

  - 通过鼠标移动来获取俯仰角与偏航角的原理：

    ```c++
    //偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离
    ```

  - 实现步骤

    1. 首先我们要告诉GLFW，它应该隐藏光标，并捕捉(Capture)它 

       ````c++
       glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
       ````

    2.  为了计算俯仰角和偏航角 ,我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下： 

       ```c++
       void mouse_callback(GLFWwindow* window, double xpos, double ypos);
       //这里的xpos和ypos代表当前鼠标的位置。
       ```

    3. 当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用： 

       ```c++
       glfwSetCursorPosCallback(window, mouse_callback);
       ```

    至此基本输入变量完成，下一步进行计算，而计算又分为以下几步：

    4. 第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是800x600）：  

       ```c++
       float lastX = 400, lastY = 300;
       //然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：
       float xoffset = xpos - lastX;
       float yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的
       lastX = xpos;
       lastY = ypos;
       
       float sensitivity = 0.05f;
       xoffset *= sensitivity;
       yoffset *= sensitivity;
       //乘以灵敏度值使得我们鼠标移动幅度在3D当中不会太大
       ```

    5. 第二步，接下来我们把偏移量加到全局变量pitch和yaw上： 

       ```c++
       yaw   += xoffset;
       pitch += yoffset;
       ```

    6. 我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：

       ```c++
       if(pitch > 89.0f)
         pitch =  89.0f;
       if(pitch < -89.0f)
         pitch = -89.0f;
       //注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。
       ```

    7. 第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量： 

       ```c++
       glm::vec3 front;
       front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));
       front.y = sin(glm::radians(pitch));
       front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));
       cameraFront = glm::normalize(front);
       ```

    为了更加逼真的效果，防止刚把鼠标移上去会产生跳动效果，我们应该加入以下检查措施

    ```c++
    if(firstMouse) // 这个bool变量初始时是设定为true的
    {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }
    ```

    
  最后，整合起来的代码：
    
    ```c++
    void mouse_callback(GLFWwindow* window, double xpos, double ypos)
    {
        if(firstMouse)
        {
            lastX = xpos;
            lastY = ypos;
            firstMouse = false;
        }
    
        float xoffset = xpos - lastX;
        float yoffset = lastY - ypos;  // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的
        lastX = xpos;
        lastY = ypos;
    
        float sensitivity = 0.05;
        xoffset *= sensitivity;
        yoffset *= sensitivity;
    
        yaw   += xoffset;
        pitch += yoffset;
    
        if(pitch > 89.0f)
            pitch = 89.0f;
        if(pitch < -89.0f)
            pitch = -89.0f;
    
        glm::vec3 front;
        front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
        front.y = sin(glm::radians(pitch));
        front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
        cameraFront = glm::normalize(front);
    }
    ```

- 缩放（使用鼠标滚轮来实现3D的缩放）

  - 定义回调函数

    ```c++
    void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
    {
      if(fov >= 1.0f && fov <= 45.0f)
        fov -= yoffset;
      if(fov <= 1.0f)
        fov = 1.0f;
      if(fov >= 45.0f)
        fov = 45.0f;
    }
    //当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小。当scroll_callback函数被调用后，我们改变全局变量fov变量的内容。因为45.0f是默认的视野值，我们将会把缩放级别(Zoom Level)限制在1.0f到45.0f。参数可以自由选择
    ```

  - 我们现在在每一帧都必须把透视投影矩阵上传到GPU，但现在使用fov变量作为它的视野： 

    ```c++
    projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);
    ```

  - 最后不要忘记注册鼠标滚轮的回调函数： 

    ```c++
    glfwSetScrollCallback(window, scroll_callback);
    ```





- 代码实现

  ```c++
  //vertexSource.txt
  #version 330 core
  layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0 
  layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1
  out vec3 ourColor; // 向片段着色器输出一个颜色
  uniform mat4 model;
  uniform mat4 view;
  uniform mat4 projection;
  void main()
  {
      gl_Position =projection * view * model * vec4(aPos, 1.0);  //顺序必须正确！
     
      ourColor = aColor;  
  }
  //fragmentSource.txt
  #version 330 core
  out vec4 FragColor;  
  in vec3 ourColor;
  void main()
  {
     FragColor = vec4(ourColor, 1.0f);
  }
  //main.cpp
  #define GLEW_STATIC
  #include <glad/glad.h>
  #include <GLFW/glfw3.h>
  #include <iostream>
  #include<MyInclude/shader_s.h>
  #include<filesystem>
  #define STB_IMAGE_IMPLEMENTATION
  #include "stb_image.h"
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  using namespace std;
  
  float vertices[] = {
      // positions          // colors           // texture coords
      // 0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
      // 0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
      //-0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
      //-0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left 
  
     - 0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 0.0f,
       0.5f, -0.5f, -0.5f,  0.0f, 1.0f, 0.0f,
       0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f,
       0.5f,  0.5f, -0.5f,  1.0f, 1.0f, 0.0f,
      -0.5f,  0.5f, -0.5f,  0.0f, 1.0f, 1.0f,
      -0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f,
  
      -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f,
       0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f,
       0.5f,  0.5f,  0.5f,  0.0f, 0.0f, 1.0f,
       0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f,
      -0.5f,  0.5f,  0.5f,  0.0f, 1.0f, 1.0f,
      -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 1.0f,
  
      -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
      -0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
      -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
      -0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
      -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
      -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,
  
       0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
       0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
       0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
       0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
       0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
       0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,
  
      -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
       0.5f, -0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
       0.5f, -0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
       0.5f, -0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
      -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
      -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 1.0f,
  
      -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
       0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
       0.5f,  0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
       0.5f,  0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
      -0.5f,  0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
      -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 1.0f
  };
  glm::vec3 cubePositions[] = {
         glm::vec3(0.0f,  0.0f,  0.0f),
         glm::vec3(2.0f,  5.0f, -15.0f),
         glm::vec3(-1.5f, -2.2f, -2.5f),
         glm::vec3(-3.8f, -2.0f, -12.3f),
         glm::vec3(2.4f, -0.4f, -3.5f),
         glm::vec3(-1.7f,  3.0f, -7.5f),
         glm::vec3(1.3f, -2.0f, -2.5f),
         glm::vec3(1.5f,  2.0f, -2.5f),
         glm::vec3(1.5f,  0.2f, -1.5f),
         glm::vec3(-1.3f,  1.0f, -1.5f)
  };
  unsigned int indices[] = {
         0, 1, 3, // first triangle
         1, 2, 3  // second triangle
  };
  
  const unsigned int SCR_WIDTH = 800;
  const unsigned int SCR_HEIGHT = 600;
  glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
  glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
  glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
  //mouse
  bool firstMouse = true;
  float yaw = -90.0f;	// yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right so we initially rotate a bit to the left.
  float pitch = 0.0f;
  float lastX = 800.0f / 2.0;
  float lastY = 600.0 / 2.0;
  float fov = 45.0f;
  // timing
  float deltaTime = 0.0f;	// time between current frame and last frame
  float lastFrame = 0.0f;
  
  //初始化函数
  void init();
  void processInput(GLFWwindow* window);
  void framebuffer_size_callback(GLFWwindow* window, int width, int height);
  void mouse_callback(GLFWwindow* window, double xpos, double ypos);
  void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
  int main()
  {
      init();
      //创建窗口
      GLFWwindow* window = glfwCreateWindow(800, 600, "MutiColor_Triangle", NULL, NULL);
  
      if (window == NULL)
      {
          std::cout << "failed to create window...." << std::endl;
          glfwTerminate();
          return -1;
      }
      //将窗口上下文设置为主线程的上下文
      glfwMakeContextCurrent(window);
      //注册回调函数
      glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
      glfwSetCursorPosCallback(window, mouse_callback);
      glfwSetScrollCallback(window, scroll_callback);
  
        // tell GLFW to capture our mouse
      glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
      //初始化GLAD库，并加载所有openGL指针
      if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
      {
          std::cout << "Failed to initialize GLAD" << std::endl;
          return -1;
      }
      glEnable(GL_DEPTH_TEST);
  
      //********************编写着色程序对象*****************************
      Shader myshader = Shader("vertexSource.txt", "fragmentSource.txt");
  
      unsigned int VBO, VAO, EBO;
      glGenVertexArrays(1, &VAO);
      glGenBuffers(1, &VBO);
      glGenBuffers(1, &EBO);
      //索引对象
      glBindVertexArray(VAO);
      glBindBuffer(GL_ARRAY_BUFFER, VBO);
      //将数据存入VBO对象
      glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
      //将索引数据存入EBO对象
      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
  
  
  
      //位置属性
      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
      glEnableVertexAttribArray(0);
      // 颜色属性
      glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
      glEnableVertexAttribArray(1);
      //纹理属性
    
      myshader.use();
      while (!glfwWindowShouldClose(window))
      {
          processInput(window);
          glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
          //glClear(GL_COLOR_BUFFER_BIT);
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!
          //glm::mat4 transform = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
          //transform = glm::rotate(transform, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
          //transform = glm::translate(transform, glm::vec3(0.5f, -0.5f, 0.0f));
          myshader.use();
          // create transformations
          //glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
        /*  float radius = 10.0f;
          float camX = sin(glfwGetTime()) * radius;
          float camZ = cos(glfwGetTime()) * radius;*/
         
          glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
  
          glm::mat4 projection = glm::mat4(1.0f);
          /*model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));*/
         // model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));
          view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
          projection = glm::perspective(glm::radians(fov), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
          // retrieve the matrix uniform locations
          unsigned int modelLoc = glGetUniformLocation(myshader.ID, "model");
          unsigned int viewLoc = glGetUniformLocation(myshader.ID, "view");
          // pass them to the shaders (3 different ways)
         // glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
          glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &view[0][0]);
          // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it's often best practice to set it outside the main loop only once.
          myshader.setMat4("projection", projection);
          glBindVertexArray(VAO);
          //glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
          for (int i = 0; i < 10; i++)
          {
              glm::mat4 model = glm::mat4(1.0f);
              model = glm::translate(model, cubePositions[i]);
              float angle = 20.0f * i;
              model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
              myshader.setMat4("model", model);
              glDrawArrays(GL_TRIANGLES, 0, 36);
          }
         // glDrawArrays(GL_TRIANGLES, 0, 36);
          
          glfwSwapBuffers(window);
          glfwPollEvents();
      }
  
      glDeleteVertexArrays(1, &VAO);
      glDeleteBuffers(1, &VBO);
      glDeleteBuffers(1, &EBO);
      glfwTerminate();
      return 0;
  }
  void init()
  {
      glfwInit();
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_CORE_PROFILE);
  #ifdef __APPLE__
      glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
  #endif
  }
  void processInput(GLFWwindow* window)
  {
      if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
          glfwSetWindowShouldClose(window, true);
      float cameraSpeed = 0.05f; // adjust accordingly
      if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
          cameraPos += cameraSpeed * cameraFront;
      if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
          cameraPos -= cameraSpeed * cameraFront;
      if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
          cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
      if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
          cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
  }
  void framebuffer_size_callback(GLFWwindow* window, int width, int height)
  {
      glViewport(0, 0, width, height);
  }
  void mouse_callback(GLFWwindow* window, double xpos, double ypos)
  {
      if (firstMouse)
      {
          lastX = xpos;
          lastY = ypos;
          firstMouse = false;
      }
  
      float xoffset = xpos - lastX;
      float yoffset = lastY - ypos;
      lastX = xpos;
      lastY = ypos;
  
      float sensitivity = 0.05;
      xoffset *= sensitivity;
      yoffset *= sensitivity;
  
      yaw += xoffset;
      pitch += yoffset;
  
      if (pitch > 89.0f)
          pitch = 89.0f;
      if (pitch < -89.0f)
          pitch = -89.0f;
  
      glm::vec3 front;
      front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
      front.y = sin(glm::radians(pitch));
      front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
      cameraFront = glm::normalize(front);
  }
  void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
  {
      if (fov >= 1.0f && fov <= 45.0f)
          fov -= yoffset;
      if (fov <= 1.0f)
          fov = 1.0f;
      if (fov >= 45.0f)
          fov = 45.0f;
  }
  ```



- 将摄像机鼠标、键盘操作封装成类，以后实验直接调用类对象即可。和着色器对象一样，我们把摄像机类写在一个单独的头文件中（.cpp文件）：

  ```c++
  #ifndef CAMERA_H
  #define CAMERA_H
  #include <glad/glad.h>
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <vector>
  // Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods
  enum Camera_Movement {
      FORWARD,
      BACKWARD,
      LEFT,
      RIGHT
  };
  
  // Default camera values
  const float YAW = -90.0f;
  const float PITCH = 0.0f;
  const float SPEED = 2.5f;
  const float SENSITIVITY = 0.1f;
  const float ZOOM = 45.0f;
  
  
  // An abstract camera class that processes input and calculates the corresponding Euler Angles, Vectors and Matrices for use in OpenGL
  class Camera
  {
  public:
      // camera Attributes
      glm::vec3 Position;
      glm::vec3 Front;
      glm::vec3 Up;
      glm::vec3 Right;
      glm::vec3 WorldUp;
      // euler Angles
      float Yaw;
      float Pitch;
      // camera options
      float MovementSpeed;
      float MouseSensitivity;
      float Zoom;
  
      // constructor with vectors
      Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
      {
          Position = position;
          WorldUp = up;
          Yaw = yaw;
          Pitch = pitch;
          updateCameraVectors();
      }
      // constructor with scalar values
      Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
      {
          Position = glm::vec3(posX, posY, posZ);
          WorldUp = glm::vec3(upX, upY, upZ);
          Yaw = yaw;
          Pitch = pitch;
          updateCameraVectors();
      }
  
      // returns the view matrix calculated using Euler Angles and the LookAt Matrix
      glm::mat4 GetViewMatrix()
      {
          return glm::lookAt(Position, Position + Front, Up);
      }
  
      // processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)
      void ProcessKeyboard(Camera_Movement direction, float deltaTime)
      {
          float velocity = MovementSpeed * deltaTime;
          if (direction == FORWARD)
              Position += Front * velocity;
          if (direction == BACKWARD)
              Position -= Front * velocity;
          if (direction == LEFT)
              Position -= Right * velocity;
          if (direction == RIGHT)
              Position += Right * velocity;
      }
  
      // processes input received from a mouse input system. Expects the offset value in both the x and y direction.
      void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true)
      {
          xoffset *= MouseSensitivity;
          yoffset *= MouseSensitivity;
  
          Yaw += xoffset;
          Pitch += yoffset;
  
          // make sure that when pitch is out of bounds, screen doesn't get flipped
          if (constrainPitch)
          {
              if (Pitch > 89.0f)
                  Pitch = 89.0f;
              if (Pitch < -89.0f)
                  Pitch = -89.0f;
          }
  
          // update Front, Right and Up Vectors using the updated Euler angles
          updateCameraVectors();
      }
  
      // processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis
      void ProcessMouseScroll(float yoffset)
      {
          Zoom -= (float)yoffset;
          if (Zoom < 1.0f)
              Zoom = 1.0f;
          if (Zoom > 45.0f)
              Zoom = 45.0f;
      }
  
  private:
      // calculates the front vector from the Camera's (updated) Euler Angles
      void updateCameraVectors()
      {
          // calculate the new Front vector
          glm::vec3 front;
          front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
          front.y = sin(glm::radians(Pitch));
          front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
          Front = glm::normalize(front);
          // also re-calculate the Right and Up vector
          Right = glm::normalize(glm::cross(Front, WorldUp));  // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.
          Up = glm::normalize(glm::cross(Right, Front));
      }
  };
  #endif
  ```

- 调用方法：

  1. 加入类

     ```c++
     #include "Camera.cpp"
     ```

  2. 声明全局Camera对象

     ```c++
     Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));
     //传入的是摄像机位置向量
     ```

  3. 用类方法替换

     ```c++
      //1. 注册
     glfwSetCursorPosCallback(window, mouse_callback);
     glfwSetScrollCallback(window, scroll_callback);
     //2. 替换view
      glm::mat4 view = camera.GetViewMatrix();
     //3. 修改perspective
      projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
     //4. mouse_callback回调函数
     void mouse_callback(GLFWwindow* window, double xpos, double ypos)
     {
         if (firstMouse)
         {
             lastX = xpos;
             lastY = ypos;
             firstMouse = false;
         }
     
         float xoffset = xpos - lastX;
         float yoffset = lastY - ypos;
         lastX = xpos;
         lastY = ypos;
         camera.ProcessMouseMovement(xoffset, yoffset);
     }
     //5. scroll_callback回调函数
     void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
     {
         camera.ProcessMouseScroll(yoffset);
     }
     // 6. void processInput函数修改
     void processInput(GLFWwindow* window)
     {
         if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
             glfwSetWindowShouldClose(window, true);
     
         if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
             camera.ProcessKeyboard(FORWARD, deltaTime);
         if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
             camera.ProcessKeyboard(BACKWARD, deltaTime);
         if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
             camera.ProcessKeyboard(LEFT, deltaTime);
         if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
             camera.ProcessKeyboard(RIGHT, deltaTime);
     }
     ```

     

4. 完整代码

   ```c++
   #define GLEW_STATIC
   #include <glad/glad.h>
   #include <GLFW/glfw3.h>
   #include <iostream>
   #include<MyInclude/shader_s.h>
   #include<filesystem>
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"
   #include <glm/glm.hpp>
   #include <glm/gtc/matrix_transform.hpp>
   #include <glm/gtc/type_ptr.hpp>
   #include "Camera.cpp"
   using namespace std;
   
   float vertices[] = {
       // positions          // colors           // texture coords
       // 0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
       // 0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
       //-0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
       //-0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left 
   
      - 0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 0.0f,
        0.5f, -0.5f, -0.5f,  0.0f, 1.0f, 0.0f,
        0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f,
        0.5f,  0.5f, -0.5f,  1.0f, 1.0f, 0.0f,
       -0.5f,  0.5f, -0.5f,  0.0f, 1.0f, 1.0f,
       -0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f,
   
       -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f,
        0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f,
        0.5f,  0.5f,  0.5f,  0.0f, 0.0f, 1.0f,
        0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f,
       -0.5f,  0.5f,  0.5f,  0.0f, 1.0f, 1.0f,
       -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 1.0f,
   
       -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
       -0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
       -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
       -0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
       -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
       -0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,
   
        0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 0.0f,
        0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
        0.5f, -0.5f, -0.5f,   0.0f, 0.0f, 1.0f,
        0.5f, -0.5f, -0.5f,   1.0f, 1.0f, 0.0f,
        0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
        0.5f,  0.5f,  0.5f,   1.0f, 0.0f, 1.0f,
   
       -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
        0.5f, -0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
        0.5f, -0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
        0.5f, -0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
       -0.5f, -0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
       -0.5f, -0.5f, -0.5f,   1.0f, 0.0f, 1.0f,
   
       -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 0.0f,
        0.5f,  0.5f, -0.5f,   0.0f, 1.0f, 0.0f,
        0.5f,  0.5f,  0.5f,   0.0f, 0.0f, 1.0f,
        0.5f,  0.5f,  0.5f,   1.0f, 1.0f, 0.0f,
       -0.5f,  0.5f,  0.5f,   0.0f, 1.0f, 1.0f,
       -0.5f,  0.5f, -0.5f,   1.0f, 0.0f, 1.0f
   };
   glm::vec3 cubePositions[] = {
          glm::vec3(0.0f,  0.0f,  0.0f),
          glm::vec3(2.0f,  5.0f, -15.0f),
          glm::vec3(-1.5f, -2.2f, -2.5f),
          glm::vec3(-3.8f, -2.0f, -12.3f),
          glm::vec3(2.4f, -0.4f, -3.5f),
          glm::vec3(-1.7f,  3.0f, -7.5f),
          glm::vec3(1.3f, -2.0f, -2.5f),
          glm::vec3(1.5f,  2.0f, -2.5f),
          glm::vec3(1.5f,  0.2f, -1.5f),
          glm::vec3(-1.3f,  1.0f, -1.5f)
   };
   unsigned int indices[] = {
          0, 1, 3, // first triangle
          1, 2, 3  // second triangle
   };
   
   const unsigned int SCR_WIDTH = 800;
   const unsigned int SCR_HEIGHT = 600;
   glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
   glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
   glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
   Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));
   //mouse
   bool firstMouse = true;
   float yaw = -90.0f;	// yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right so we initially rotate a bit to the left.
   float pitch = 0.0f;
   float lastX = 800.0f / 2.0;
   float lastY = 600.0 / 2.0;
   float fov = 45.0f;
   // timing
   float deltaTime = 0.0f;	// time between current frame and last frame
   float lastFrame = 0.0f;
   
   //初始化函数
   void init();
   void processInput(GLFWwindow* window);
   void framebuffer_size_callback(GLFWwindow* window, int width, int height);
   void mouse_callback(GLFWwindow* window, double xpos, double ypos);
   void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
   int main()
   {
       init();
       //创建窗口
       GLFWwindow* window = glfwCreateWindow(800, 600, "MutiColor_Triangle", NULL, NULL);
   
       if (window == NULL)
       {
           std::cout << "failed to create window...." << std::endl;
           glfwTerminate();
           return -1;
       }
       //将窗口上下文设置为主线程的上下文
       glfwMakeContextCurrent(window);
       //注册回调函数
       glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
       glfwSetCursorPosCallback(window, mouse_callback);
       glfwSetScrollCallback(window, scroll_callback);
   
         // tell GLFW to capture our mouse
       glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
       //初始化GLAD库，并加载所有openGL指针
       if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
       {
           std::cout << "Failed to initialize GLAD" << std::endl;
           return -1;
       }
       glEnable(GL_DEPTH_TEST);
   
       //********************编写着色程序对象*****************************
       Shader myshader = Shader("vertexSource.txt", "fragmentSource.txt");
   
       unsigned int VBO, VAO, EBO;
       glGenVertexArrays(1, &VAO);
       glGenBuffers(1, &VBO);
       glGenBuffers(1, &EBO);
       //索引对象
       glBindVertexArray(VAO);
       glBindBuffer(GL_ARRAY_BUFFER, VBO);
       //将数据存入VBO对象
       glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
       //将索引数据存入EBO对象
       glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
       glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
   
   
   
       //位置属性
       glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
       glEnableVertexAttribArray(0);
       // 颜色属性
       glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
       glEnableVertexAttribArray(1);
       //纹理属性
     
       myshader.use();
       while (!glfwWindowShouldClose(window))
       {
           float currentFrame = glfwGetTime();
           deltaTime = currentFrame - lastFrame;
           lastFrame = currentFrame;
           processInput(window);
           glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
           //glClear(GL_COLOR_BUFFER_BIT);
           glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!
           //glm::mat4 transform = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
           //transform = glm::rotate(transform, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
           //transform = glm::translate(transform, glm::vec3(0.5f, -0.5f, 0.0f));
           myshader.use();
           // create transformations
           //glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first
         /*  float radius = 10.0f;
           float camX = sin(glfwGetTime()) * radius;
           float camZ = cos(glfwGetTime()) * radius;*/
          
          // glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
           glm::mat4 view = camera.GetViewMatrix();
           myshader.setMat4("view", view);
          // glm::mat4 projection = glm::mat4(1.0f);
           /*model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));*/
          // model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));
           //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
           glm::mat4  projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
           // retrieve the matrix uniform locations
           //unsigned int modelLoc = glGetUniformLocation(myshader.ID, "model");
          // unsigned int viewLoc = glGetUniformLocation(myshader.ID, "view");
           // pass them to the shaders (3 different ways)
          // glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
           //glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &view[0][0]);
           // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it's often best practice to set it outside the main loop only once.
           myshader.setMat4("projection", projection);
           glBindVertexArray(VAO);
           //glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
           for (int i = 0; i < 10; i++)
           {
               glm::mat4 model = glm::mat4(1.0f);
               model = glm::translate(model, cubePositions[i]);
               float angle = 20.0f * i;
               model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
               myshader.setMat4("model", model);
               glDrawArrays(GL_TRIANGLES, 0, 36);
           }
          // glDrawArrays(GL_TRIANGLES, 0, 36);
           
           glfwSwapBuffers(window);
           glfwPollEvents();
       }
   
       glDeleteVertexArrays(1, &VAO);
       glDeleteBuffers(1, &VBO);
       glDeleteBuffers(1, &EBO);
       glfwTerminate();
       return 0;
   }
   void init()
   {
       glfwInit();
       glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
       glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
       glfwWindowHint(GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   #ifdef __APPLE__
       glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
   #endif
   }
   void processInput(GLFWwindow* window)
   {
       if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
           glfwSetWindowShouldClose(window, true);
   
       if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
           camera.ProcessKeyboard(FORWARD, deltaTime);
       if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
           camera.ProcessKeyboard(BACKWARD, deltaTime);
       if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
           camera.ProcessKeyboard(LEFT, deltaTime);
       if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
           camera.ProcessKeyboard(RIGHT, deltaTime);
   }
   void framebuffer_size_callback(GLFWwindow* window, int width, int height)
   {
       glViewport(0, 0, width, height);
   }
   void mouse_callback(GLFWwindow* window, double xpos, double ypos)
   {
       if (firstMouse)
       {
           lastX = xpos;
           lastY = ypos;
           firstMouse = false;
       }
   
       float xoffset = xpos - lastX;
       float yoffset = lastY - ypos;
       lastX = xpos;
       lastY = ypos;
       camera.ProcessMouseMovement(xoffset, yoffset);
   }
   void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
   {
       camera.ProcessMouseScroll(yoffset);
   }
   ```

   